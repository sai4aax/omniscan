#!/usr/bin/env python3

# device.py
# A device API for devices implementing Blue Robotics ping-protocol

# ~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!
# THIS IS AN AUTOGENERATED FILE
# DO NOT EDIT
# ~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!

import sys
import time
from collections import deque
import serial
import socket
import logging

from . import definitions
from . import pingmessage

DEBUG = False
ERROR = True
INFO = True
def debug(message):
    if DEBUG:
        print(f"[DEBUG]: {message}")

def error(message):
    if ERROR:
        print(f"[ERROR]: {message}")

def info(message):
    if INFO:
        print(f"[INFO]: {message}")

class PingDevice(object):
    _input_buffer = deque()

    def __init__(self):
        ## A helper class to take care of decoding the input stream
        self.parser = pingmessage.PingParser()

        ## device id of this Ping1D object, used for dst_device_id in outgoing messages
        self.my_id = 255

        # IO device
        self.iodev = None
        self.server_address = None # Tuple (host, port) for UDP/TCP connections
        self.device_name = None # Name of the serial device (e.g., '/dev/ttyUSB0')
        self.baudrate = 115200  # Default baudrate for serial connections
        
        self.connection_type = None # 'serial', 'udp', or 'tcp'
        self.logger = logging.getLogger(__name__)
        
        self.timeout = 2.0  # Default timeout for socket operations
        self.wait_time = 0.5 # try after this amount of time if there is no data now
        self.max_number_of_tries = int(self.timeout/self.wait_time)
        
    def connect(self):
        if self.connection_type == "serial":
            error("Connecting to serial device...")
            if not self.device_name:
                raise ValueError("Device name is required for serial connection.")
            if not self.baudrate:
                raise ValueError("Baudrate is required for serial connection.")
            info(f"Connecting to serial device {self.device_name} at {self.baudrate} bps")
            self.connect_serial()
        elif self.connection_type == "udp":
            error("Connecting to UDP server...")
            if not self.server_address:
                raise ValueError("Server address is required for UDP connection.")      
            self.connect_udp()
        elif self.connection_type == "tcp":
            error("Connecting to TCP server...")
            if not self.server_address:
                raise ValueError("Server address is required for TCP connection.")
            info(f"Connecting to TCP server at {self.server_address}...")
            self.connect_tcp() 
        else:
            error(f"Invalid connection type{self.connection_type}. Must be 'serial', 'udp', or 'tcp'.")
   
    def connect_serial(self):
        if self.is_connected():
            self.disconnect()

        if not self.device_name:
            raise ValueError("Device name is required for serial connection.")

        try:
            info(f"Opening serial device {self.device_name} at {self.baudrate} bps")
            self.iodev = serial.Serial(self.device_name, self.baudrate, timeout=self.timeout, write_timeout=self.timeout)
            self.connection_type = "serial"
        except serial.SerialException as e:
            self.disconnect()
            error(f"Failed to open serial port {self.device_name}: {e}")

    def connect_udp(self): 
        if self.is_connected():
        # if True:
            print(f"reconnecting to udp port {self.server_address}")
        
        else:
            if not self.server_address:
                print("Server address is required for UDP connection.")
                
            print(f"Connecting to UDP server at {self.server_address}...")
            self.iodev = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.iodev.settimeout(self.timeout)
            # For UDP, connect() just sets the default remote address
            self.iodev.connect(self.server_address)
            self.connection_type = "udp"

                             
        # while not self.is_sensor_online():
        #     print("Sensor is offline, attempting to reconnect...")
        #     time.sleep(1.0)  # Wait before retrying

        info(f"Opened UDP socket at {self.server_address}")
        self.connection_type = "udp"
            
    def connect_tcp(self, retry_delay: float = 1.0):
        while True:
            try:
                info(f"Connecting to TCP server at {self.server_address}...")
                self.iodev = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                self.iodev.settimeout(self.timeout)
                self.iodev.connect(self.server_address)
                self.connection_type = "tcp"
                info("TCP connection established.")
                return
            except (socket.timeout, socket.gaierror, socket.error) as e:
                error(f"TCP connection failed: {e}")
                self.disconnect()
                time.sleep(retry_delay)   

    def is_sensor_online(self):
        if self.iodev is None:
            return False
        
        if self.connection_type == "serial":
            try:
                self.iodev = serial.Serial(self.device_name, self.baudrate, timeout=self.timeout, write_timeout=self.timeout)
                return True
            except serial.SerialException as e:
                return False
        elif self.connection_type == "tcp":
            debug("from is_sensor_online -> checking if socket is online")
            try:
                # result = self.iodev.send(b"")  # Send empty packet to check
                # print("Socket is online", result)
                return True
            except socket.error:
                return False
        elif self.connection_type == "udp" :
            debug("we have to send a request to check if the sensor is online")
            return True
        else:
            debug("Invalid connection type. Must be 'serial', 'udp', or 'tcp'.")
            return False
            
            
    def is_connected(self) -> bool:
        return self.iodev is not None

    def disconnect(self):
        if self.iodev:
            try:
                debug(f"Disconnecting device: {self.iodev}")
                self.iodev.close()
            except Exception as e:
                error(f"Error while disconnecting: {e}", exc_info=True)
            finally:
                self.iodev = None  
                
    def read_io(self):          
        try:
            if self.connection_type == 'serial':
                data = self.iodev.read(4096)
                self._input_buffer.extendleft(data)
            elif self.connection_type in ['udp', 'tcp']:
                data = self.iodev.recv(4096)
                self._input_buffer.extendleft(data)

            debug(f"got {len(data)} bytes of data into buffer")
            return True
        except serial.SerialException as e:
            debug(f"Serial device disconnected: {e}")
            return False
        except socket.timeout:
            debug("Socket timeout, no data received.")
            return False
        except socket.error as e:
            debug(f"Socket read error: {e}. Attempting to reconnect...")
            return False
        except Exception as e:
            debug(f"An unexpected error occurred during read: {e}")
            return False

    def read(self):
        try:
            debug("Reading data from IO device...")
            reading_status =  self.read_io()
            if reading_status:
                debug("parsing the data from the buffer")
                while len(self._input_buffer):
                    b = self._input_buffer.pop()
                    if self.parser.parse_byte(b) == pingmessage.PingParser.NEW_MESSAGE:
                        if self.handle_message(self.parser.rx_msg):
                            return self.parser.rx_msg
            else:
                debug("Failed to read from IO device, reading status is False.")
                return None
        except ConnectionError as e:
            error(f"Connection error in read(): {e}", file=sys.stderr)
            return None

        return None

    def write(self, data):
        if not self.is_connected():
            error("IO device is not connected.")
            self.connect()
        data_sent = False
        debug(f"writing {data} to the sensor")
        while not data_sent:
            try:
                if self.connection_type == 'serial':
                    return self.iodev.write(data)
                elif self.connection_type == "tcp":
                    return self.iodev.send(data)
                elif self.connection_type == "udp":
                    return self.iodev.send(data)
                data_sent = True
                
            except serial.SerialException as e:
                debug(f"Failed to write to serial device: {e}")
                
            except socket.error as e:
                debug(f"Socket write error: {e}. Attempting to reconnect...")
            except Exception as e:
                debug(f"An unexpected error occurred during write: {e}")


    def initialize(self):
        if not self.is_sensor_online():
            print("Cannot initialize, device is not online.", file=sys.stderr)
            return False
        debug("sending a request to get protocol version -> initialization")
        return self.request(definitions.COMMON_GET_DEVICE_INFORMATION) is not None

    def request(self, m_id):
        msg = pingmessage.PingMessage(definitions.COMMON_GENERAL_REQUEST)
        msg.requested_id = m_id
        msg.pack_msg_data()
        
        # debug("\n\n")
        debug("sending message:")
        debug(msg)
        self.write(msg.msg_data)
        
        got_response = False
        number_of_tries = 0
        while not got_response:
            if number_of_tries == self.max_number_of_tries:
                error("disconnected :(")
            number_of_tries += 1

            # print("")
            debug(f"waiting for the response")
            rx_msg = self.read()
            if rx_msg is not None:
                # print("\n")
                debug(f"message we got \n{rx_msg}")
                if rx_msg.message_id == msg.requested_id:
                    if number_of_tries >= self.max_number_of_tries:
                        error("sensor connected :)")
                    debug("got the requested message")
                    got_response = True
                    return rx_msg
                elif rx_msg.message_id == definitions.COMMON_GENERAL_NACK:
                    debug("got nack message")
                    debug(f"nack_id : {rx_msg.nacked_id}")
                    debug(f"nack_message : {rx_msg.nack_message}")
            else:
                debug("timeout so again sending the message")
                time.sleep(self.wait_time)
                debug("\n\n")
                debug(f"sending message: \n{msg}\n")
                self.write(msg.msg_data)
                

        # A nack is a valid response, wait for it
        # return self.wait_message([m_id, definitions.COMMON_GENERAL_NACK])
        # return self.wait_message([m_id])

    def wait_message(self, message_ids):       
        # uncomment the following lines if you want to get the message before the timeout
        tstart = time.time()
        while time.time() < tstart + self.timeout:
            msg = self.read()
            if msg is not None and msg.message_id in message_ids:
                return msg
            time.sleep(0.005)  # Small sleep to avoid busy-waiting
        return None
            
            

    def handle_message(self, msg):
        # TODO: check if this message is for us (dst_device_id)
        setattr(self, "_src_device_id", msg.src_device_id)
        setattr(self, "_dst_device_id", msg.dst_device_id)

        if msg.message_id in pingmessage.payload_dict:
            try:
                for attr in pingmessage.payload_dict[msg.message_id]["field_names"]:
                    setattr(self, "_" + attr, getattr(msg, attr))
                return True
            except AttributeError as e:
                error(f"Attribute error while handling msg {msg.message_id} ({msg.name}): {e}", file=sys.stderr)
                return False
        else:
            error(f"Unrecognized message: {msg.message_id}", file=sys.stderr)
            return False

    def __repr__(self):
        connection_status = "connected" if self.is_connected() else "disconnected"
        return (f"PingDevice(connection={self.connection_type}, "
                f"address={self.server_address or 'N/A'}, status={connection_status})")

    def get_device_information(self):
        if self.request(definitions.COMMON_GET_DEVICE_INFORMATION) is None:
            return None
        return {
            "device_type": self._device_type,
            "device_revision": self._device_revision,
            "firmware_version_major": self._firmware_version_major,
            "firmware_version_minor": self._firmware_version_minor,
            "firmware_version_patch": self._firmware_version_patch,
            "reserved": self._reserved,  # reserved
        }

    def get_protocol_version(self):
        if self.request(definitions.COMMON_GET_PROTOCOL_VERSION) is None:
            return None
        return {
            "version_major": self._version_major,
            "version_minor": self._version_minor,
            "version_patch": self._version_patch,
            "reserved": self._reserved,  # reserved
        }


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Ping python library example.")
    parser.add_argument('--device', action="store", required=False, type=str, help="Ping device port. E.g: /dev/ttyUSB0")
    parser.add_argument('--baudrate', action="store", type=int, default=115200, help="Ping device baudrate. E.g: 115200")
    parser.add_argument('--udp', action="store", required=False, type=str, help="Ping UDP server. E.g: 0.0.0.0:12345")
    parser.add_argument('--tcp', action="store", required=False, type=str, help="Ping TCP server. E.g: 127.0.0.1:12345")
    args = parser.parse_args()

    if not any([args.device, args.udp, args.tcp]):
        parser.print_help()
        exit(1)

    p = PingDevice()


    try:
        if args.device:
            p.device_name = args.device
            p.baudrate = args.baudrate
            p.connection_type = 'serial'
        elif args.udp:
            host, port_str = args.udp.split(':')
            p.server_address = (host, int(port_str))
            p.connection_type = 'udp'
        elif args.tcp:
            host, port_str = args.tcp.split(':')
            p.server_address = (host, int(port_str))
            p.connection_type = 'tcp'
        else:
            print("No valid connection parameters provided.", file=sys.stderr)
            parser.print_help()
            exit(1)
            
        p.connect()

        if not p.initialize():
            error("Failed to initialize device.", file=sys.stderr)
            exit(1)

        # info("Initialized: True")
        # info(p)

        # info("\nTesting get_device_information")
        # info = p.get_device_information()
        # if info:
        #     info(f"  {info}")
        #     info("  >> pass: True <<")
        # else:
        #     error("  >> pass: False <<")

        # info("\nTesting get_protocol_version")
        # proto = p.get_protocol_version()
        # if proto:
        #     info(f"  {proto}")
        #     info("  >> pass: True <<")
        # else:
        #     error("  >> pass: False <<")

    except (ConnectionError, ValueError) as e:
        error(f"Error: {e}", file=sys.stderr)
        exit(1)
    finally:
        p.disconnect()
