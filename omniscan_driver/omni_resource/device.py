#!/usr/bin/env python3

# device.py
# A device API for devices implementing Blue Robotics ping-protocol

# ~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!
# THIS IS AN AUTOGENERATED FILE
# DO NOT EDIT
# ~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!

import sys
import time
from collections import deque
import serial
import socket

from . import definitions
from . import pingmessage


class PingDevice(object):
    _input_buffer = deque()

    def __init__(self):
        ## A helper class to take care of decoding the input stream
        self.parser = pingmessage.PingParser()

        ## device id of this Ping1D object, used for dst_device_id in outgoing messages
        self.my_id = 255

        # IO device
        self.iodev = None
        self.connection_type = None
        self.server_address = None

    def connect_serial(self, device_name: str, baudrate: int = 115200, timeout: float = 5.0):
        if self.is_connected():
            self.disconnect()

        if not device_name:
            raise ValueError("Device name is required for serial connection.")

        try:
            print(f"Opening serial device {device_name} at {baudrate} bps")
            self.iodev = serial.Serial(device_name, baudrate, timeout=timeout, write_timeout=timeout)
            self.connection_type = "serial"
        except serial.SerialException as e:
            self.disconnect()
            raise ConnectionError(f"Failed to open serial port {device_name}: {e}")

    def connect_udp(self, host: str, port: int, timeout: float = 5.0):
        # TODO: if this script starting before the UDP server, it will fail to connect. and not able to reconnect in the timeout period.
        if self.is_connected():
            self.disconnect()

        self.server_address = (host, port)
        try:
            print(f"Opening UDP socket at {host}:{port}")
            self.iodev = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.iodev.settimeout(timeout)
            # For UDP, connect() just sets the default remote address
            self.iodev.connect(self.server_address)
            self.connection_type = "udp"
        except socket.gaierror as e:
            raise ConnectionError(f"Hostname {host} could not be resolved: {e}")
        except socket.error as e:
            self.disconnect()
            raise ConnectionError(f"Failed to open UDP socket at {host}:{port}: {e}")

    def connect_tcp(self, host: str, port: int, timeout: float = 5.0):
        if self.is_connected():
            self.disconnect()

        self.server_address = (host, port)
        try:
            print(f"Opening TCP socket at {host}:{port}")
            self.iodev = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.iodev.settimeout(timeout)
            self.iodev.connect(self.server_address)
            self.connection_type = "tcp"
        except socket.timeout:
            self.disconnect()
            raise ConnectionError(f"Connection to TCP server {host}:{port} timed out after {timeout} seconds.")
        except socket.gaierror as e:
            raise ConnectionError(f"Hostname {host} could not be resolved: {e}")
        except socket.error as e:
            self.disconnect()
            raise ConnectionError(f"Failed to connect to TCP server at {host}:{port}: {e}")

    def disconnect(self):
        if self.iodev is not None:
            try:
                self.iodev.close()
            except Exception as e:
                print(f"Error while disconnecting: {e}", file=sys.stderr)
            finally:
                self.iodev = None
                self.connection_type = None
                self.server_address = None

    def is_connected(self):
        return self.iodev is not None

    def read_io(self):
        if not self.is_connected():
            raise ConnectionError("IO device is not connected.")
        try:
            if self.connection_type == 'serial':
                data = self.iodev.read(4096)
                self._input_buffer.extendleft(data)
            elif self.connection_type in ['udp', 'tcp']:
                data = self.iodev.recv(4096)
                self._input_buffer.extendleft(data)
        except serial.SerialException as e:
            self.disconnect()
            raise ConnectionError(f"Serial device disconnected: {e}")
        except socket.timeout:
            # This is expected if no data is available on a socket with a timeout
            pass
        except socket.error as e:
            self.disconnect()
            raise ConnectionError(f"Socket disconnected: {e}")
        except Exception as e:
            self.disconnect()
            raise ConnectionError(f"An unexpected error occurred during read: {e}")

    def read(self):
        try:
            self.read_io()
        except ConnectionError as e:
            # print(f"Connection error in read(): {e}", file=sys.stderr)
            return None

        while len(self._input_buffer):
            b = self._input_buffer.pop()
            if self.parser.parse_byte(b) == pingmessage.PingParser.NEW_MESSAGE:
                if self.handle_message(self.parser.rx_msg):
                    return self.parser.rx_msg
        return None

    def write(self, data):
        if not self.is_connected():
            raise ConnectionError("IO device is not connected.")
        try:
            if self.connection_type == 'serial':
                return self.iodev.write(data)
            elif self.connection_type in ['udp', 'tcp']:
                return self.iodev.send(data)
        except serial.SerialException as e:
            self.disconnect()
            raise ConnectionError(f"Failed to write to serial device: {e}")
        except socket.error as e:
            self.disconnect()
            raise ConnectionError(f"Failed to write to socket: {e}")
        except Exception as e:
            self.disconnect()
            raise ConnectionError(f"An unexpected error occurred during write: {e}")

    def initialize(self):
        if not self.is_connected():
            print("Cannot initialize, device not connected.", file=sys.stderr)
            return False
        return self.request(definitions.COMMON_GET_PROTOCOL_VERSION) is not None

    def request(self, m_id, timeout=0.5):
        msg = pingmessage.PingMessage(definitions.COMMON_GENERAL_REQUEST)
        msg.requested_id = m_id
        msg.pack_msg_data()
        try:
            self.write(msg.msg_data)
        except ConnectionError as e:
            print(f"Failed to send request: {e}", file=sys.stderr)
            return None

        # A nack is a valid response, wait for it
        return self.wait_message([m_id, definitions.COMMON_GENERAL_NACK], timeout)
        return self.wait_message([m_id], timeout)

    def wait_message(self, message_ids, timeout=1.2):
        tstart = time.time()
        while time.time() < tstart + timeout:
            msg = self.read()
            if msg is not None and msg.message_id in message_ids:
                return msg
            time.sleep(0.005)  # Small sleep to avoid busy-waiting
        return None

    def handle_message(self, msg):
        # TODO: check if this message is for us (dst_device_id)
        setattr(self, "_src_device_id", msg.src_device_id)
        setattr(self, "_dst_device_id", msg.dst_device_id)

        if msg.message_id in pingmessage.payload_dict:
            try:
                for attr in pingmessage.payload_dict[msg.message_id]["field_names"]:
                    setattr(self, "_" + attr, getattr(msg, attr))
                return True
            except AttributeError as e:
                print(f"Attribute error while handling msg {msg.message_id} ({msg.name}): {e}", file=sys.stderr)
                return False
        else:
            print(f"Unrecognized message: {msg.message_id}", file=sys.stderr)
            return False

    def __repr__(self):
        connection_status = "connected" if self.is_connected() else "disconnected"
        return (f"PingDevice(connection={self.connection_type}, "
                f"address={self.server_address or 'N/A'}, status={connection_status})")

    def get_device_information(self):
        if self.request(definitions.COMMON_GET_DEVICE_INFORMATION) is None:
            return None
        return {
            "device_type": self._device_type,
            "device_revision": self._device_revision,
            "firmware_version_major": self._firmware_version_major,
            "firmware_version_minor": self._firmware_version_minor,
            "firmware_version_patch": self._firmware_version_patch,
            "reserved": self._reserved,  # reserved
        }

    def get_protocol_version(self):
        if self.request(definitions.COMMON_GET_PROTOCOL_VERSION) is None:
            return None
        return {
            "version_major": self._version_major,
            "version_minor": self._version_minor,
            "version_patch": self._version_patch,
            "reserved": self._reserved,  # reserved
        }


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Ping python library example.")
    parser.add_argument('--device', action="store", required=False, type=str, help="Ping device port. E.g: /dev/ttyUSB0")
    parser.add_argument('--baudrate', action="store", type=int, default=115200, help="Ping device baudrate. E.g: 115200")
    parser.add_argument('--udp', action="store", required=False, type=str, help="Ping UDP server. E.g: 0.0.0.0:12345")
    parser.add_argument('--tcp', action="store", required=False, type=str, help="Ping TCP server. E.g: 127.0.0.1:12345")
    args = parser.parse_args()

    if not any([args.device, args.udp, args.tcp]):
        parser.print_help()
        exit(1)

    p = PingDevice()

    try:
        if args.device:
            p.connect_serial(args.device, args.baudrate)
        elif args.udp:
            host, port_str = args.udp.split(':')
            p.connect_udp(host, int(port_str))
        elif args.tcp:
            host, port_str = args.tcp.split(':')
            p.connect_tcp(host, int(port_str))

        if not p.initialize():
            print("Failed to initialize device.", file=sys.stderr)
            exit(1)

        print("Initialized: True")
        print(p)

        print("\nTesting get_device_information")
        info = p.get_device_information()
        if info:
            print(f"  {info}")
            print("  >> pass: True <<")
        else:
            print("  >> pass: False <<")

        print("\nTesting get_protocol_version")
        proto = p.get_protocol_version()
        if proto:
            print(f"  {proto}")
            print("  >> pass: True <<")
        else:
            print("  >> pass: False <<")

    except (ConnectionError, ValueError) as e:
        print(f"Error: {e}", file=sys.stderr)
        exit(1)
    finally:
        p.disconnect()
